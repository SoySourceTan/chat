<!DOCTYPE html>
<html lang="ja" data-bs-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Forrest Aura</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="/favicon.ico" type="全メッセージクリアをしても消えませんでしたimage/x-icon">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
</head>
<body class="d-flex flex-column vh-100">
  <!-- ナビゲーションバー -->
  <nav class="navbar navbar-expand-lg navbar-light bg-light fixed-top">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Forrest Aura</a>
      <div class="ms-auto d-flex align-items-center">
        <span id="user-info" class="cursor-pointer" tabindex="0" aria-label="ユーザー名編集">ゲスト <i class="fas fa-pencil-alt ms-1"></i></span>
        <button id="login-btn" class="btn btn-outline-primary ms-2">ログイン</button>
      </div>
    </div>
  </nav>

  <!-- メインコンテンツ -->
  <main class="container mt-5 mb-5 pb-5 d-flex flex-column">
    <div id="error-alert" class="alert alert-danger d-none" role="alert"></div>
    <div class="d-flex justify-content-center">
      <button id="newMessageBtn" class="btn btn-primary btn-sm btn-floating d-none" tabindex="0" aria-label="新着メッセージにスクロール">
        <i class="fas fa-arrow-down"></i>
      </button>
    </div>
    <div class="messages-container flex-grow-1" style="overflow: hidden;">
      <ul id="messages" class="list-group" role="list">
      </ul>
    </div>
    </div>
  </main>

  <footer class="bg-light py-2 fixed-bottom" style="z-index: 1050;">
    <div class="container">
      <form id="messageForm" class="needs-validation w-100" novalidate>
        <div class="row g-2 justify-content-center align-items-center">
          <div class="col-md-10 d-flex align-items-center">
            <button type="button" id="toggleModeBtn" class="btn btn-outline-secondary btn-sm me-2" data-bs-toggle="tooltip" data-bs-placement="top" title="送信モード" aria-label="送信モードに切り替え">
              <i class="fas fa-paper-plane"></i>
            </button>
            <textarea id="m" class="form-control" placeholder="メッセージを入力" rows="2" autocomplete="off" required aria-label="メッセージ入力"></textarea>
            <div class="invalid-feedback">メッセージを入力してください。</div>
          </div>
          <div class="col-md-2">
            <button type="submit" id="submit-btn" class="btn btn-primary btn-sm w-100">送信</button>
          </div>
        </div>
      </form>
    </div>
  </footer>

<!-- ログインモーダル -->
  <div class="modal fade" id="loginModal" tabindex="-1" aria-labelledby="loginModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="loginModalLabel">ログイン</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="閉じる"></button>
        </div>
        <div class="modal-body">
          <div class="d-grid gap-2">
            <button id="twitterLogin" class="btn btn-outline-dark"><i class="fab fa-x-twitter me-2"></i>Xでログイン</button>
            <button id="googleLogin" class="btn btn-outline-danger"><i class="fab fa-google me-2"></i>Googleでログイン</button>
            <button id="anonymousLogin" class="btn btn-outline-secondary"><i class="fa-solid fa-user-secret me-2"></i>匿名でログイン</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<!-- ユーザー名設定モーダル -->
  <div class="modal fade" id="unameModal" tabindex="-1" aria-labelledby="unameModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="unameModalLabel">ユーザー名設定</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="閉じる"></button>
        </div>
        <div class="modal-body">
          <input type="text" id="uname" class="form-control mb-3" placeholder="名前を入力してください" aria-label="ユーザー名" required>
          <div class="invalid-feedback">名前を入力してください。</div>
          <div class="d-grid gap-2">
            <button id="confirmName" class="btn btn-primary">確定</button>
            <button id="signOut" class="btn btn-outline-danger">ログアウト</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<!-- スクリプト -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
  <script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js';
import { getDatabase, ref, push, onChildAdded, set, get, query, orderByChild, limitToLast, endAt } from 'https://www.gstatic.com/firebasejs/11.0.1/firebase-database.js';
import { getAuth, GoogleAuthProvider, TwitterAuthProvider, signInWithPopup, signInAnonymously, signOut } from 'https://www.gstatic.com/firebasejs/11.0.1/firebase-auth.js';

const firebaseConfig = {
  apiKey: "AIzaSyBLMySLkXyeiL2_QLCdolHTOOA6W3TSfYc",
  authDomain: "gentle-brace-458923-k9.firebaseapp.com",
  databaseURL: "https://gentle-brace-458923-k9-default-rtdb.firebaseio.com",
  projectId: "gentle-brace-458923-k9",
  storageBucket: "gentle-brace-458923-k9.firebasestorage.app",
  messagingSenderId: "426876531009",
  appId: "1:426876531009:web:021b23c449bce5d72031c0",
  measurementId: "G-2B5KWNHYED"
};

try {
  const app = initializeApp(firebaseConfig);
  const database = getDatabase(app);
  const auth = getAuth(app);
  console.log('Firebase初期化成功');
  const messagesRef = ref(database, 'messages');
  const usersRef = ref(database, 'users');
  const actionsRef = ref(database, 'actions');
  const bannedUsersRef = ref(database, 'bannedUsers');

  const formEl = document.getElementById('messageForm');
  const messagesEl = document.getElementById('messages');
  const inputEl = document.getElementById('m');
  const errorAlert = document.getElementById('error-alert');
  const loginBtn = document.getElementById('login-btn');
  const twitterLogin = document.getElementById('twitterLogin');
  const googleLogin = document.getElementById('googleLogin');
  const anonymousLogin = document.getElementById('anonymousLogin');
  const userInfo = document.getElementById('user-info');
  const unameModalEl = document.getElementById('unameModal');
  const unameModal = new bootstrap.Modal(unameModalEl);
  const loginModalEl = document.getElementById('loginModal');
  const loginModal = new bootstrap.Modal(loginModalEl);
  const unameInput = document.getElementById('uname');
  const confirmName = document.getElementById('confirmName');
  const signOutBtn = document.getElementById('signOut');
  const newMessageBtn = document.getElementById('newMessageBtn');
  const toggleModeBtn = document.getElementById('toggleModeBtn');

  let isLoggingIn = false;
  let isUserScrolledUp = false;
  let isEnterSendMode = true;
  let isLoading = false;
  let lastTimestamp = null;

  function showError(message) {
    errorAlert.textContent = message;
    errorAlert.classList.remove('d-none');
    setTimeout(() => errorAlert.classList.add('d-none'), 3000);
  }

  function showSuccess(message) {
    const successAlert = document.createElement('div');
    successAlert.className = 'alert alert-success';
    successAlert.setAttribute('role', 'alert');
    successAlert.textContent = message;
    document.body.appendChild(successAlert);
    setTimeout(() => successAlert.remove(), 3000);
  }

  async function updateUserUI(user) {
    try {
      if (user) {
        const userData = await get(ref(database, `users/${user.uid}`));
        const userDataVal = userData.val();
        const username = userDataVal?.username || user.displayName || 'ゲスト';
        userInfo.innerHTML = `${username} <i class="fas fa-pencil-alt ms-1"></i>`;
        loginBtn.textContent = 'ログアウト';
        loginModal.hide();
        loginModalEl.setAttribute('inert', '');
        if ((user.isAnonymous || !userDataVal?.username) && !isLoggingIn) {
          unameInput.value = userDataVal?.username || '';
          unameModalEl.removeAttribute('inert');
          unameModal.show();
          setTimeout(() => unameInput.focus(), 100);
        }
      } else {
        userInfo.innerHTML = 'ゲスト <i class="fas fa-pencil-alt ms-1"></i>';
        loginBtn.textContent = 'ログイン';
        unameModalEl.setAttribute('inert', '');
        loginModalEl.removeAttribute('inert');
        loginModal.show();
        setTimeout(() => document.getElementById('twitterLogin').focus(), 100);
      }
    } catch (error) {
      console.error('ユーザーUI更新エラー:', error);
      showError('ユーザー情報の更新に失敗しました。');
    }
  }

  toggleModeBtn.addEventListener('click', () => {
    isEnterSendMode = !isEnterSendMode;
    toggleModeBtn.innerHTML = isEnterSendMode ? '<i class="fas fa-paper-plane"></i>' : '<i class="fas fa-level-down-alt fa-rotate-90"></i>';
    toggleModeBtn.setAttribute('data-bs-title', isEnterSendMode ? '送信モード' : '改行モード');
    toggleModeBtn.setAttribute('aria-label', isEnterSendMode ? '送信モードに切り替え' : '改行モードに切り替え');
    new bootstrap.Tooltip(toggleModeBtn).show();
    setTimeout(() => bootstrap.Tooltip.getInstance(toggleModeBtn).hide(), 1000);
    console.log('モード切り替え:', isEnterSendMode ? '送信モード' : '改行モード');
  });

  inputEl.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey && isEnterSendMode) {
      e.preventDefault();
      formEl.dispatchEvent(new Event('submit'));
    } else if (e.key === 'Enter' && e.shiftKey && isEnterSendMode) {
      e.preventDefault();
      inputEl.value += '\n';
      inputEl.scrollTop = inputEl.scrollHeight;
    }
  });

  messagesEl.addEventListener('scroll', async () => {
    const scrollBottom = messagesEl.scrollHeight - messagesEl.clientHeight - messagesEl.scrollTop;
    isUserScrolledUp = messagesEl.scrollTop > 10;
    newMessageBtn.classList.toggle('d-none', !isUserScrolledUp);
    console.log('スクロール位置:', messagesEl.scrollTop, 'scrollBottom:', scrollBottom);
    if (scrollBottom < 100 && !isLoading) {
      isLoading = true;
      try {
        const messages = messagesEl.querySelectorAll('[data-timestamp]');
        lastTimestamp = messages.length ? Math.min(...Array.from(messages).map(m => Number(m.getAttribute('data-timestamp')))) : null;
        if (lastTimestamp) {
          const olderMessages = await get(query(messagesRef, orderByChild('timestamp'), endAt(lastTimestamp - 1), limitToLast(10)));
          const olderMessagesArray = olderMessages.val() ? Object.entries(olderMessages.val()).sort((a, b) => b[1].timestamp - a[1].timestamp) : [];
          for (const [key, { username, message, timestamp, userId, ipAddress }] of olderMessagesArray) {
            if (messagesEl.querySelector(`[data-message-id="${key}"]`)) continue; // 重複防止
            const isOwnMessage = userId === (auth.currentUser?.uid || '');
            const userData = await get(ref(database, `users/${userId}`));
            const provider = userData.val()?.provider || 'anonymous';
            const iconClass = provider === 'twitter.com' ? 'fa-brands fa-x-twitter' :
                             provider === 'google.com' ? 'fa-brands fa-google' :
                             'fa-solid fa-user-secret';
            const li = document.createElement('li');
            li.className = `list-group-item d-flex ${isOwnMessage ? 'justify-content-end' : 'justify-content-start'} align-items-start border-0 fade-in`;
            li.setAttribute('data-message-id', key);
            li.setAttribute('role', 'listitem');
            li.setAttribute('data-timestamp', timestamp);
            const date = timestamp ? new Date(timestamp).toLocaleString('ja-JP') : '不明';
            li.innerHTML = `
              <div class="message ${isOwnMessage ? 'bg-primary text-white' : 'bg-light'} p-3 rounded shadow-sm">
                <div class="message-header d-flex align-items-center">
            <div class="avatar me-2 ${provider === 'twitter.com' ? 'bg-dark' : provider === 'google.com' ? 'bg-danger' : 'bg-secondary'}">${username ? username.charAt(0).toUpperCase() : '?'}</div>
                  <i class="${iconClass} me-2 provider-icon"></i>
                  <strong>${username || '匿名'}</strong>
                  <small class="text-muted ms-2">${date}</small>
                </div>
                <div class="message-body">
                  ${message ? message.replace(/\n/g, '<br>') : 'メッセージなし'}
                </div>
              </div>`;
            messagesEl.append(li);
            setTimeout(() => li.classList.add('show'), 10);
          }
          console.log('過去メッセージロード完了: メッセージ数=', olderMessagesArray.length);
        }
      } catch (error) {
        console.error('過去メッセージ取得エラー:', error);
        showError('過去メッセージの取得に失敗しました。');
      } finally {
        isLoading = false;
      }
    }
  });

  twitterLogin.addEventListener('click', async () => {
    if (isLoggingIn) return;
    isLoggingIn = true;
    const provider = new TwitterAuthProvider();
    try {
      const result = await signInWithPopup(auth, provider);
      const user = result.user;
      const providerId = result.providerId || 'twitter.com';
      const existingUserData = (await get(ref(database, `users/${user.uid}`))).val();
      const username = existingUserData?.username || user.displayName || `user${Date.now()}`;
      await set(ref(database, `users/${user.uid}`), {
        username,
        provider: providerId,
        ipAddress: 'github'
      });
      await push(actionsRef, {
        type: 'connect',
        userId: user.uid,
        username,
        timestamp: Date.now()
      });
      console.log('Xログイン成功:', user.displayName);
      await updateUserUI(user);
      showSuccess('Xでログインしました。');
    } catch (error) {
      console.error('Xログインエラー:', error);
      showError('Xログインに失敗しました: ' + error.message);
    } finally {
      isLoggingIn = false;
    }
  });

  googleLogin.addEventListener('click', async () => {
    if (isLoggingIn) return;
    isLoggingIn = true;
    const provider = new GoogleAuthProvider();
    try {
      const result = await signInWithPopup(auth, provider);
      const user = result.user;
      const providerId = result.providerId || 'google.com';
      const existingUserData = (await get(ref(database, `users/${user.uid}`))).val();
      const username = existingUserData?.username || user.displayName || `user${Date.now()}`;
      await set(ref(database, `users/${user.uid}`), {
        username,
        provider: providerId,
        ipAddress: 'github'
      });
      await push(actionsRef, {
        type: 'connect',
        userId: user.uid,
        username,
        timestamp: Date.now()
      });
      console.log('Googleログイン成功:', user.displayName);
      await updateUserUI(user);
      showSuccess('Googleでログインしました。');
    } catch (error) {
      console.error('Googleログインエラー:', error);
      showError('Googleログインに失敗しました: ' + error.message);
    } finally {
      isLoggingIn = false;
    }
  });

  anonymousLogin.addEventListener('click', async () => {
    if (isLoggingIn) return;
    isLoggingIn = true;
    try {
      const result = await signInAnonymously(auth);
      const user = result.user;
      const uniqueUsername = `anon${Date.now()}`;
      await set(ref(database, `users/${user.uid}`), {
        username: uniqueUsername,
        provider: 'anonymous',
        ipAddress: 'github'
      });
      await push(actionsRef, {
        type: 'connect',
        userId: user.uid,
        username: uniqueUsername,
        timestamp: Date.now()
      });
      console.log('匿名ログイン成功');
      await updateUserUI(user);
      showSuccess('匿名でログインしました。');
    } catch (error) {
      console.error('匿名ログインエラー:', error);
      showError('匿名ログインに失敗しました: ' + error.message);
    } finally {
      isLoggingIn = false;
    }
  });

  loginBtn.addEventListener('click', async () => {
    console.log('loginBtnクリック: 現在のユーザー:', auth.currentUser);
    if (auth.currentUser) {
      try {
        await push(actionsRef, {
          type: 'logout',
          userId: auth.currentUser.uid,
          username: userInfo.textContent,
          timestamp: Date.now()
        });
        await signOut(auth);
        console.log('ログアウト成功');
        showSuccess('ログアウトしました。');
      } catch (error) {
        console.error('ログアウトエラー:', error);
        showError('ログアウトに失敗しました: ' + error.message);
      }
    } else {
      loginModalEl.removeAttribute('inert');
      loginModal.show();
      setTimeout(() => document.getElementById('twitterLogin').focus(), 100);
      console.log('ログインモーダル表示');
    }
  });

  signOutBtn.addEventListener('click', async () => {
    console.log('signOutBtnクリック: ログアウト開始');
    try {
      await push(actionsRef, {
        type: 'logout',
        userId: auth.currentUser.uid,
        username: userInfo.textContent,
        timestamp: Date.now()
      });
      await signOut(auth);
      unameModal.hide();
      unameModalEl.setAttribute('inert', '');
      document.getElementById('login-btn').focus();
      console.log('ログアウト成功');
      showSuccess('ログアウトしました。');
    } catch (error) {
      console.error('ログアウトエラー:', error);
      showError('ログアウトに失敗しました: ' + error.message);
    }
  });

  userInfo.addEventListener('click', async () => {
    if (auth.currentUser) {
      const userData = await get(ref(database, `users/${auth.currentUser.uid}`));
      unameInput.value = userData.val()?.username || '';
      unameModalEl.removeAttribute('inert');
      unameModal.show();
      setTimeout(() => unameInput.focus(), 100);
      console.log('unameModal表示: uname入力欄にフォーカス');
    } else {
      showError('ログインしてください。');
    }
  });

  confirmName.addEventListener('click', async () => {
    console.log('confirmNameクリック: 入力値=', unameInput.value);
    const username = unameInput.value.trim();
    if (username === '') {
      unameInput.classList.add('is-invalid');
      console.log('ユーザー名エラー: 空文字');
      return;
    }
    if (!auth.currentUser) {
      showError('ログインしてください。');
      console.log('ユーザー名エラー: 未ログイン');
      return;
    }
    try {
      console.log('ユーザー名設定試行: UID=', auth.currentUser.uid, 'username=', username);
      const userData = (await get(ref(database, `users/${auth.currentUser.uid}`))).val();
      await set(ref(database, `users/${auth.currentUser.uid}`), {
        username,
        provider: userData?.provider || 'anonymous',
        ipAddress: userData?.ipAddress || 'github'
      });
      await push(actionsRef, {
        type: 'setUsername',
        userId: auth.currentUser.uid,
        username,
        timestamp: Date.now()
      });
      userInfo.innerHTML = `${username} <i class="fas fa-pencil-alt ms-1"></i>`;
      unameModal.hide();
      unameInput.classList.remove('is-invalid');
      console.log('ユーザー名設定成功:', username);
      showSuccess('ユーザー名を更新しました。');
    } catch (error) {
      console.error('ユーザー名設定エラー:', error);
      showError('ユーザー名の保存に失敗しました: ' + error.message);
    }
  });

  formEl.addEventListener('submit', async (e) => {
    e.preventDefault();
    if (!formEl.checkValidity()) {
      e.stopPropagation();
      formEl.classList.add('was-validated');
      return;
    }
    if (!auth.currentUser) {
      showError('ログインしてください。');
      return;
    }
    const banned = (await get(ref(database, `bannedUsers/${auth.currentUser.uid}`))).val();
    if (banned) {
      showError('あなたはBANされています。メッセージを送信できません。');
      return;
    }
    const message = inputEl.value.trim();
    if (message.length === 0) {
      showError('メッセージを入力してください。');
      return;
    }
    if (message.length > 500) {
      showError('メッセージは500文字以内にしてください。');
      return;
    }
    try {
      const userData = (await get(ref(database, `users/${auth.currentUser.uid}`))).val();
      const timestamp = Date.now();
      console.log('メッセージ送信: timestamp=', timestamp);
      await push(messagesRef, {
        username: userInfo.textContent,
        message,
        timestamp,
        userId: auth.currentUser.uid,
        ipAddress: userData?.ipAddress || 'github'
      });
      await push(actionsRef, {
        type: 'sendMessage',
        userId: auth.currentUser.uid,
        username: userInfo.textContent,
        timestamp
      });
      inputEl.value = '';
      formEl.classList.remove('was-validated');
      isUserScrolledUp = false;
      messagesEl.scrollTo({ top: 0, behavior: 'smooth' });
      newMessageBtn.classList.add('d-none');
      console.log('メッセージ送信成功: スクロール位置=', messagesEl.scrollTop);
    } catch (error) {
      console.error('メッセージ送信エラー:', error);
      showError('メッセージの送信に失敗しました: ' + error.message);
    }
  });

  inputEl.addEventListener('input', () => {
    inputEl.style.height = 'auto';
    inputEl.style.height = `${Math.min(inputEl.scrollHeight, 120)}px`;
  });

  // 初期ロード（最新10件）
  async function loadInitialMessages() {
    try {
      const initialMessagesQuery = query(messagesRef, orderByChild('timestamp'), limitToLast(10));
      const snapshot = await get(initialMessagesQuery);
      for (const [key, { username, message, timestamp, userId, ipAddress }] of messages) {
        console.log(`メッセージ: key=${key}, timestamp=${timestamp}, username=${username}`);
        const isOwnMessage = userId === (auth.currentUser?.uid || '');
        const isLatest = key === messages[0][0];
        const userData = await get(ref(database, `users/${userId}`));
        const provider = userData.val()?.provider || 'anonymous';
        const iconClass = provider === 'twitter.com' ? 'fa-brands fa-x-twitter' :
                         provider === 'google.com' ? 'fa-brands fa-google' :
                         'fa-solid fa-user-secret';
        const li = document.createElement('li');
        li.className = `list-group-item d-flex ${isOwnMessage ? 'justify-content-end' : 'justify-content-start'} align-items-start border-0 ${isLatest ? 'latest-message pulse' : ''} fade-in`;
        li.setAttribute('data-message-id', key);
        li.setAttribute('role', 'listitem');
        li.setAttribute('data-timestamp', timestamp);
        const date = timestamp ? new Date(timestamp).toLocaleString('ja-JP') : '不明';
        li.innerHTML = `
          <div class="message ${isOwnMessage ? 'bg-primary text-white' : 'bg-light'} p-3 rounded shadow-sm">
            <div class="message-header d-flex align-items-center">
              <div class="avatar me-2 ${provider === 'twitter.com' ? 'bg-dark' : provider === 'google.com' ? 'bg-danger' : 'bg-secondary'}">${username ? username.charAt(0).toUpperCase() : '?'}</div>
              <i class="${iconClass} me-2 provider-icon"></i>
              <strong>${username || '匿名'}</strong>
              <small class="text-muted ms-2">${date}</small>
            </div>
            <div class="message-body">
              ${message ? message.replace(/\n/g, '<br>') : 'メッセージなし'}
            </div>
          </div>`;
        messagesEl.prepend(li);
        setTimeout(() => li.classList.add('show'), 10);
      }
      console.log('初期メッセージロード完了: メッセージ数=', messages.length);
    } catch (e) {
      console.error("初期メッセージ読み込みエラー", e);
      showError("メッセージの読み込みに失敗しました");
    }
  }
  loadInitialMessages();

  // 新しいメッセージのリアルタイム追加
  onChildAdded(messagesRef, async (snapshot) => {
    try {
      const { username, message, timestamp, userId, ipAddress } = snapshot.val();
      const key = snapshot.key;
      if (messagesEl.querySelector(`[data-message-id="${key}"]`)) return; // 重複防止
      console.log(`新メッセージ追加: key=${key}, timestamp=${timestamp}, username=${username}`);
      const isOwnMessage = userId === (auth.currentUser?.uid || '');
      const userData = await get(ref(database, `users/${userId}`));
      const provider = userData.val()?.provider || 'anonymous';
      const iconClass = provider === 'twitter.com' ? 'fa-brands fa-x-twitter' :
                       provider === 'google.com' ? 'fa-brands fa-google' :
                       'fa-solid fa-user-secret';
      const li = document.createElement('li');
      li.className = `list-group-item d-flex ${isOwnMessage ? 'justify-content-end' : 'justify-content-start'} align-items-start border-0 fade-in latest-message pulse`;
      li.setAttribute('data-message-id', key);
      li.setAttribute('role', 'listitem');
      li.setAttribute('data-timestamp', timestamp);
      const date = timestamp ? new Date(timestamp).toLocaleString('ja-JP') : '不明';
      li.innerHTML = `
        <div class="message ${isOwnMessage ? 'text-gray' : 'bg-light'} p-3 rounded shadow-sm">
          <div class="message-header d-flex align-items-center">
            <div class="avatar me-2 ${provider === 'twitter.com' ? 'bg-dark' : provider === 'google.com' ? 'bg-danger' : 'bg-secondary'}">${username ? username.charAt(0).toUpperCase() : '?'}</div>
            <i class="${iconClass} me-2 provider-icon"></i>
            <strong>${username || '匿名'}</strong>
            <small class="text-muted ms-2">${date}</small>
          </div>
          <div class="message-body">
            ${message ? message.replace(/\n/g, '<br>') : 'メッセージなし'}
          </div>
        </div>`;
      messagesEl.prepend(li);
      setTimeout(() => li.classList.add('show'), 10);
      if (!isUserScrolledUp) {
        messagesEl.scrollTo({ top: 0, behavior: 'smooth' });
        newMessageBtn.classList.add('d-none');
        console.log('新メッセージ追加後: スクロール位置=', messagesEl.scrollTop);
      } else {
        newMessageBtn.classList.remove('d-none');
      }
    } catch (error) {
      console.error('新メッセージ追加エラー:', error);
      showError('メッセージの取得に失敗しました。');
    }
  });

  auth.onAuthStateChanged(async (user) => {
    try {
      console.log('認証状態変更:', user ? `ログイン済み (UID: ${user.uid})` : '未ログイン');
      await updateUserUI(user);
    } catch (error) {
      console.error('認証状態変更エラー:', error);
      showError('認証状態の更新に失敗しました: ' + error.message);
    }
  });

  unameModalEl.addEventListener('hidden.bs.modal', () => {
    unameModalEl.setAttribute('inert', '');
    document.getElementById('login-btn').focus();
    console.log('unameModal非表示: フォーカスをlogin-btnに移動');
  });

  loginModalEl.addEventListener('hidden.bs.modal', () => {
    loginModalEl.setAttribute('inert', '');
    document.getElementById('login-btn').focus();
    console.log('loginModal非表示: フォーカスをlogin-btnに移動');
  });

  newMessageBtn.addEventListener('click', () => {
    messagesEl.scrollTo({ top: 0, behavior: 'smooth' });
    isUserScrolledUp = false;
    newMessageBtn.classList.add('d-none');
    console.log('newMessageBtnクリック: 最上部にスクロール');
  });

  // 初期メッセージ読み込み
  loadInitialMessages();

  window.onload = () => {
    console.log('ページロード: スクロール位置を維持');
    document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach((el) => new bootstrap.Tooltip(el));
  };
} catch (error) {
  console.error('Firebase初期化エラー:', {
    message: error.message,
    code: error.code,
    stack: error.stack
  });
  showError(`Firebaseの初期化に失敗しました: ${error.message}`);
}
  </script>
</body>
</html>